# tests/test_annotations.py
# This code is entirely generated by ChatGPT5

import sys
import types
import importlib
import numpy as np
import pytest


# ---- Minimal fake ANTs shim -------------------------------------------------
class FakeAntsImage:
    """
    Tiny stand-in for ants.ANTsImage with just enough behavior for tests:
    - holds a numpy array
    - stores simple metadata (spacing/origin/direction)
    - .view() returns the ndarray (mirrors ANTsPy behavior)
    """
    def __init__(self, array, spacing=None, origin=None, direction=None):
        self._arr = np.asarray(array)
        self.spacing = spacing if spacing is not None else (1.0, 1.0, 1.0)
        self.origin = origin if origin is not None else (0.0, 0.0, 0.0)
        # ANTs typically stores a flattened direction cosine matrix
        if direction is None:
            self.direction = tuple(np.eye(self._arr.ndim, dtype=float).ravel())
        else:
            self.direction = tuple(direction)

    def view(self):
        return self._arr

    # convenience for comparing in assertions
    def __repr__(self):
        return f"FakeAntsImage(shape={self._arr.shape}, dtype={self._arr.dtype})"


def fake_from_numpy(arr):
    return FakeAntsImage(np.asarray(arr))


def fake_copy_image_info(src, dest):
    """
    Copy spatial metadata FROM src TO dest and return dest.
    This matches the usual "copy from -> to" semantics many libraries use.
    """
    dest.spacing = getattr(src, "spacing", (1.0, 1.0, 1.0))
    dest.origin = getattr(src, "origin", (0.0, 0.0, 0.0))
    dest.direction = getattr(src, "direction", tuple(np.eye(dest.view().ndim).ravel()))
    return dest


def fake_apply_transforms(fixed, moving, transformlist=None, interpolator="nearestNeighbor"):
    """
    For unit tests we don't need geometric warping; we only want to validate
    the label mapping round-trip. So we simply return the moving image unchanged.
    """
    assert interpolator == "nearestNeighbor", "Nearest-neighbor expected for labels"
    return moving


def _install_fake_ants_in_sys_modules(monkeypatch):
    fake_ants = types.SimpleNamespace(
        from_numpy=fake_from_numpy,
        copy_image_info=fake_copy_image_info,
        apply_transforms=fake_apply_transforms,
    )
    # Ensure any import of 'ants' grabs our shim
    monkeypatch.setitem(sys.modules, "ants", fake_ants)
    return fake_ants


# ---- Fixtures ---------------------------------------------------------------
@pytest.fixture(scope="module")
def annotations_module(monkeypatch):
    """
    Import a fresh copy of aind_registration_utils.annotations with our fake
    'ants' module injected BEFORE import, so the module binds to the shim.
    """
    _install_fake_ants_in_sys_modules(monkeypatch)
    # Re-import module cleanly
    if "aind_registration_utils.annotations" in sys.modules:
        del sys.modules["aind_registration_utils.annotations"]
    mod = importlib.import_module("aind_registration_utils.annotations")
    return mod


# ---- Tests ------------------------------------------------------------------
def test_roundtrip_preserves_labels_small_ints(annotations_module):
    map_annotations_safely = annotations_module.map_annotations_safely

    # Small integer labels with repeats
    arr = np.array([[0, 3, 3],
                    [2, 2, 1]], dtype=np.int32)
    moving = FakeAntsImage(arr, spacing=(2.0, 2.0, 2.0), origin=(1, 1, 1))
    fixed = FakeAntsImage(np.zeros_like(arr))

    out = map_annotations_safely(moving, fixed, transformlist=[])

    # Values unchanged
    np.testing.assert_array_equal(out.view(), arr)
    # Output should carry fixed's spatial metadata
    assert out.spacing == fixed.spacing
    assert out.origin == fixed.origin
    assert out.direction == fixed.direction
    # dtype preserved (important for downstream)
    assert out.view().dtype == arr.dtype


def test_roundtrip_preserves_huge_integer_labels(annotations_module):
    map_annotations_safely = annotations_module.map_annotations_safely

    # Mix of small and very large labels; use unsigned to test > 2**31
    huge_vals = np.array([0, 42, 2**40 + 123, 2**48 + 7, 999_999_999_999], dtype=np.uint64)
    arr = huge_vals.reshape(1, -1)
    moving = FakeAntsImage(arr, spacing=(0.5, 0.5, 0.5))
    fixed = FakeAntsImage(np.zeros_like(arr))

    out = map_annotations_safely(moving, fixed, transformlist=[])

    np.testing.assert_array_equal(out.view(), arr)
    assert out.spacing == fixed.spacing
    # dtype preserved (should remain uint64 here)
    assert out.view().dtype == arr.dtype


def test_inputs_not_mutated(annotations_module):
    map_annotations_safely = annotations_module.map_annotations_safely

    arr = np.array([[10, 10], [20, 30]], dtype=np.int64)
    moving = FakeAntsImage(arr.copy(), spacing=(3.0, 3.0, 3.0))
    fixed = FakeAntsImage(np.zeros_like(arr), spacing=(1.0, 1.0, 1.0))

    # Keep original copies for comparison
    moving_before = moving.view().copy()
    fixed_before_spacing = fixed.spacing

    _ = map_annotations_safely(moving, fixed, transformlist=[])

    # Ensure original arrays and metadata unchanged
    np.testing.assert_array_equal(moving.view(), moving_before)
    assert fixed.spacing == fixed_before_spacing


def test_uses_nearest_neighbor_interpolator(annotations_module, monkeypatch):
    """
    Ensure nearest-neighbor is used when warping the temporary integer image.
    Our fake apply_transforms asserts this; here we also verify call was made.
    """
    calls = {"count": 0}

    def spying_apply_transforms(fixed, moving, transformlist=None, interpolator="nearestNeighbor"):
        calls["count"] += 1
        # Delegate to the default fake behavior (and assertion)
        return fake_apply_transforms(fixed, moving, transformlist, interpolator)

    # Patch the module's bound 'ants' to spy on apply_transforms
    fake_ants = sys.modules["ants"]
    monkeypatch.setattr(fake_ants, "apply_transforms", spying_apply_transforms, raising=True)

    map_annotations_safely = annotations_module.map_annotations_safely
    arr = np.array([[1, 2], [3, 4]], dtype=np.int16)
    moving = FakeAntsImage(arr)
    fixed = FakeAntsImage(np.zeros_like(arr))

    _ = map_annotations_safely(moving, fixed, transformlist=["dummy"])

    assert calls["count"] == 1
